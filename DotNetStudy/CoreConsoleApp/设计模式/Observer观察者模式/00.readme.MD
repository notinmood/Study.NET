# 说明
## 拉模式 vs 推模式
- 推模型 目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当于是在广播通信。推模式是目标对象对观察者单向依赖的。
- 拉模型 目标对象在通知观察者的时候，只传递少量信息(比如仅传递目标对象自身)，如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。拉模式观察者和目标对象是双向依赖的。

推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。

推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是干脆重新实现观察者。

而拉模型就不会造成这样的情况，因为拉模型下，update方法的参数是目标对象本身，这基本上是目标对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

本例中，拉模式下，目标将自身传递给了观察者；推模式下，目标对象是将字符串message传递给了观察者。


## 观察者模式 vs 发布/订阅模式
观察者模式和订阅者模式并不是完全相同的概念，它们之间有一些显著的区别。虽然观察者模式和订阅者模式在某些方面有相似之处，但它们在角色定义、调度方式和消息处理等方面存在明显的区别。因此，不能将它们视为完全相同的概念。

### 角色和关系：

- 观察者模式中，观察者（Observer）和被观察者（Subject）是直接交互的。观察者知道被观察者的存在，并且被观察者会维护一个观察者的集合。
- 订阅者模式（发布订阅模式）中，发布者（Publisher）和订阅者（Subscriber）之间是完全解耦的。发布者通过一个第三方调度中心（如事件中心或消息队列）来发布消息，订阅者则注册到这个调度中心并接收消息。
### 调度方式：

- 在观察者模式中，被观察者负责调度，当其状态发生变化时，会自动通知所有注册的观察者。
- 在订阅者模式中，调度工作由第三方调度中心完成，发布者和订阅者互不感知对方的存在。
### 消息处理：

- 观察者模式中，消息的生产和消费与消息对象本身紧密关联，即消息对象本身包含了对观察者的引用。
- 订阅者模式中，消息的生产和消费与消息对象本身没有直接关系，消息对象只是传递信息的载体，发布者和订阅者通过调度中心进行通信。
### 适用场景：

- 观察者模式适用于对象间存在一对多依赖关系的场景，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。
- 订阅者模式适用于对象间存在多对多关系的场景，特别是在需要高内聚、低耦合的系统架构中，可以有效地解耦组件之间的依赖关系。

参考资料：
- https://www.jianshu.com/p/aa7ee3c96986